{
  "methods": {
    "ANY_ID()": {
      "stateMutability": "view",
      "code": "function ANY_ID() external view returns (uint16)",
      "inputs": {},
      "outputs": {
        "_0": {
          "type": "uint16",
          "description": "Set to zero (0)"
        }
      },
      "notice": "The value of \"open Noun ID\" which allows trait matches to be performed against any Noun ID except non-auctioned Nouns"
    },
    "AUCTION_END_LIMIT()": {
      "stateMutability": "view",
      "code": "function AUCTION_END_LIMIT() external view returns (uint16)",
      "inputs": {},
      "outputs": {
        "_0": {
          "type": "uint16",
          "description": "Set to 5 minutes"
        }
      },
      "notice": "Time limit before an auction ends; requests cannot be removed during this time"
    },
    "acceptOwnership()": {
      "stateMutability": "nonpayable",
      "code": "function acceptOwnership() external nonpayable",
      "inputs": {},
      "outputs": {},
      "details": "The new owner accepts the ownership transfer."
    },
    "accessoryCount()": {
      "stateMutability": "view",
      "code": "function accessoryCount() external view returns (uint16)",
      "inputs": {},
      "outputs": {
        "_0": {
          "type": "uint16",
          "description": "accessoryCount"
        }
      },
      "notice": "the total number of accessory traits, fetched and cached via `updateTraitCounts()`"
    },
    "add(uint8,uint16,uint16,uint16)": {
      "stateMutability": "payable",
      "code": "function add(enum NounSeek.Traits trait, uint16 traitId, uint16 nounId, uint16 recipientId) external payable returns (uint256 requestId)",
      "inputs": {
        "trait": {
          "type": "enum NounSeek.Traits",
          "description": "Trait Type the request is for (see `Traits` Enum)"
        },
        "traitId": {
          "type": "uint16",
          "description": "ID of the specified Trait that the request is for"
        },
        "nounId": {
          "type": "uint16",
          "description": "the Noun ID the request is targeted for (or the value of ANY_ID for open requests)"
        },
        "recipientId": {
          "type": "uint16",
          "description": "the ID of the Recipient that should receive the pledge if a Noun matching the parameters is minted"
        }
      },
      "outputs": {
        "requestId": {
          "type": "uint256",
          "description": "The ID of this requests for msg.sender's address"
        }
      },
      "notice": "Create a request for the specific trait and specific or open Noun ID payable to the specified Recipient.",
      "details": "`msg.value` is used as the pledged Request amount"
    },
    "addRecipient(string,address,string)": {
      "stateMutability": "nonpayable",
      "code": "function addRecipient(string name, address to, string description) external nonpayable",
      "inputs": {
        "name": {
          "type": "string",
          "description": "The Recipient's name that should be displayed to users/consumers"
        },
        "to": {
          "type": "address",
          "description": "Address that funds should be sent to in order to fund the Recipient"
        },
        "description": {
          "type": "string"
        }
      },
      "outputs": {},
      "notice": "Add a Recipient by specifying the name and address funds should be sent to",
      "details": "Adds a Recipient to the recipients set and activates the Recipient"
    },
    "addWithMessage(uint8,uint16,uint16,uint16,string)": {
      "stateMutability": "payable",
      "code": "function addWithMessage(enum NounSeek.Traits trait, uint16 traitId, uint16 nounId, uint16 recipientId, string message) external payable returns (uint256 requestId)",
      "inputs": {
        "trait": {
          "type": "enum NounSeek.Traits",
          "description": "Trait Type the request is for (see `Traits` Enum)"
        },
        "traitId": {
          "type": "uint16",
          "description": "ID of the specified Trait that the request is for"
        },
        "nounId": {
          "type": "uint16",
          "description": "the Noun ID the request is targeted for (or the value of ANY_ID for open requests)"
        },
        "recipientId": {
          "type": "uint16",
          "description": "the ID of the Recipient that should receive the pledge if a Noun matching the parameters is minted"
        },
        "message": {
          "type": "string",
          "description": "The message to log"
        }
      },
      "outputs": {
        "requestId": {
          "type": "uint256",
          "description": "The ID of this requests for msg.sender's address"
        }
      },
      "notice": "Create a request with a logged message for the specific trait and specific or open Noun ID payable to the specified Recipient.",
      "details": "The message cost is subtracted from `msg.value` and transfered immediately to the specified Recipient. The remaining value is stored as the pledged Request amount request."
    },
    "amounts(bytes32,uint16)": {
      "stateMutability": "view",
      "code": "function amounts(bytes32, uint16) external view returns (uint256)",
      "inputs": {
        "_0": {
          "type": "bytes32"
        },
        "_1": {
          "type": "uint16"
        }
      },
      "outputs": {
        "_0": {
          "type": "uint256"
        }
      },
      "notice": "Cumulative funds for trait parameters send to a specific recipient. The first mapping key is can be generated with the `traitsHash` function and the second is recipientId"
    },
    "auctionHouse()": {
      "stateMutability": "view",
      "code": "function auctionHouse() external view returns (contract INounsAuctionHouseLike)",
      "inputs": {},
      "outputs": {
        "_0": {
          "type": "contract INounsAuctionHouseLike",
          "description": "auctionHouse contract address"
        }
      },
      "notice": "Retreives the current auction data"
    },
    "backgroundCount()": {
      "stateMutability": "view",
      "code": "function backgroundCount() external view returns (uint16)",
      "inputs": {},
      "outputs": {
        "_0": {
          "type": "uint16",
          "description": "backgroundCount"
        }
      },
      "notice": "the total number of background traits, fetched and cached via `updateTraitCounts()`"
    },
    "baseReimbursementBPS()": {
      "stateMutability": "view",
      "code": "function baseReimbursementBPS() external view returns (uint16)",
      "inputs": {},
      "outputs": {
        "_0": {
          "type": "uint16",
          "description": "baseReimbursementBPS"
        }
      },
      "notice": "A portion of donated funds are sent to the address performing a match; owner can update"
    },
    "bodyCount()": {
      "stateMutability": "view",
      "code": "function bodyCount() external view returns (uint16)",
      "inputs": {},
      "outputs": {
        "_0": {
          "type": "uint16",
          "description": "bodyCount"
        }
      },
      "notice": "the total number of body traits, fetched and cached via `updateTraitCounts()`"
    },
    "pledgesForMatchableNoun()": {
      "stateMutability": "view",
      "code": "function pledgesForMatchableNoun() external view returns (uint16 auctionedNounId, uint16 nonAuctionedNounId, uint256[][5] auctionedNounPledges, uint256[][5] nonAuctionedNounPledges, uint256[5] totalPledgesPerTrait, uint256[5] reimbursementPerTrait)",
      "inputs": {},
      "outputs": {
        "auctionedNounId": {
          "type": "uint16",
          "description": "The ID of the Noun that is was auctioned"
        },
        "nonAuctionedNounId": {
          "type": "uint16",
          "description": "If two Nouns were minted, this will be the ID of the non-auctioned Noun, otherwise uint16.max (65,535)"
        },
        "auctionedNounPledges": {
          "type": "uint256[][5]",
          "description": "Total pledges for the eligible auctioned Noun as a nested arrays in the order Trait Type and Recipient ID"
        },
        "nonAuctionedNounPledges": {
          "type": "uint256[][5]",
          "description": "If two Nouns were minted, this will contain the total pledges for the previous non-auctioned Noun as a nested arrays in the order Trait Type and Recipient ID"
        },
        "totalPledgesPerTrait": {
          "type": "uint256[5]",
          "description": "An array of total pledge pledged minus reimbursement across all Recipients, indexed by Trait Type"
        },
        "reimbursementPerTrait": {
          "type": "uint256[5]",
          "description": "An array of matcher's reimbursement that will be sent if a Trait Type is matched, indexed by Trait Type"
        }
      },
      "notice": "For the Noun that is eligible to be matched with pledged pledges (and the previous non-auctioned Noun if it was minted at the same time), get cumulative pledge amounts for each Recipient using requests that match the Noun's seed.",
      "details": "Example: The Noun that is eligible to match has an ID of 99 and a seed of [1,2,3,4,5] representing background, body, accessory, head, glasses Trait Types and respective Trait IDs. Calling `pledgesForMatchableNoun()` returns cumulative matching pledges for each trait that matches the seed. `auctionedNounPledges[0]` returns the cumulative doantions amounts for all requests that are seeking background (Trait Type 0) with Trait ID 1 (i.e. the actual background value) for Noun ID 99. The value in `pledges[0][2]` is in the total amount that has been pledged to Recipient ID 2. If the Noun on auction was ID 101, there would additionally be return values for Noun 100, the non-auctioned Noun minted at the same time and `nonAuctionedNounPledges` would be populated See the documentation in the function body for the cases used to match eligible Nouns"
    },
    "pledgesForNounId(uint16)": {
      "stateMutability": "view",
      "code": "function pledgesForNounId(uint16 nounId) external view returns (uint256[][][5] pledges)",
      "inputs": {
        "nounId": {
          "type": "uint16",
          "description": "The ID of the Noun requests should match."
        }
      },
      "outputs": {
        "pledges": {
          "type": "uint256[][][5]",
          "description": "Cumulative amounts pledged for each Recipient, indexed by Trait Type, Trait ID and Recipient ID"
        }
      },
      "notice": "For a given Noun ID, get cumulative pledge amounts for each Recipient scoped by Trait Type and Trait ID.",
      "details": "The pledges array is a nested structure of 3 arrays of Trait Type, Trait ID, and Recipient ID. The length of the first array is 5 (five) representing all Trait Types. The length of the second is dependant on the number of traits for that trait type (e.g. 242 for Trait Type 3 aka heads). The length of the third is dependant on the number of recipients added to this contract. Example lengths: - `pledges[0].length` == 2 representing the two traits possible for a background `cool` (Trait ID 0) and `warm` (Trait ID 1) - `pledges[0][0].length` == the size of the number of recipients that have been added to this contract. Each value is the amount that has been pledged to a specific recipient, indexed by its ID, if a Noun is minted with a cool background. Calling `pledgesForNounId(101) returns cumulative matching pledges for each Trait Type, Trait ID and Recipient ID such that:` - the value at `pledges[0][1][2]` is in the total amount that has been pledged to Recipient ID 0 if Noun 101 is minted with a warm background (Trait 0, traitId 1) - the value at `pledges[0][1][2]` is in the total amount that has been pledged to Recipient ID 0 if Noun 101 is minted with a warm background (Trait 0, traitId 1) Note: When accessing a Noun ID for an auctioned Noun, pledges for the open ID value `ANY_ID` will be added to total pledges. E.g. `pledgesForNounId(101)` fetches all pledges for the open ID value `ANY_ID` as well as specified pledges for Noun ID 101."
    },
    "pledgesForNounIdByTrait(uint8,uint16)": {
      "stateMutability": "view",
      "code": "function pledgesForNounIdByTrait(enum NounSeek.Traits trait, uint16 nounId) external view returns (uint256[][] pledgesByTraitId)",
      "inputs": {
        "trait": {
          "type": "enum NounSeek.Traits",
          "description": "The trait type to scope requests to (See `Traits` Enum)"
        },
        "nounId": {
          "type": "uint16",
          "description": "The Noun ID to scope requests to"
        }
      },
      "outputs": {
        "pledgesByTraitId": {
          "type": "uint256[][]",
          "description": "Cumulative amounts pledged for each Recipient, indexed by Trait ID and Recipient ID"
        }
      },
      "notice": "Get cumulative pledge amounts scoped to Noun ID and Trait Type.",
      "details": "Example: `pledgesForNounIdByTrait(3, 25)` accumulates all pledged pledges amounts for heads and Noun ID 25. The returned value in `pledges[5][2]` is in the total amount that has been pledged to Recipient ID 2 if Noun ID 25 is minted with a head of Trait ID 5 Note: When accessing a Noun ID for an auctioned Noun, pledges for the open ID value `ANY_ID` will be added to total pledges"
    },
    "pledgesForNounIdByTraitId(uint8,uint16,uint16)": {
      "stateMutability": "view",
      "code": "function pledgesForNounIdByTraitId(enum NounSeek.Traits trait, uint16 traitId, uint16 nounId) external view returns (uint256[] pledges)",
      "inputs": {
        "trait": {
          "type": "enum NounSeek.Traits",
          "description": "The trait type to scope requests to (See `Traits` Enum)"
        },
        "traitId": {
          "type": "uint16",
          "description": "The trait ID  of the trait to scope requests"
        },
        "nounId": {
          "type": "uint16",
          "description": "The Noun ID to scope requests to"
        }
      },
      "outputs": {
        "pledges": {
          "type": "uint256[]",
          "description": "Cumulative amounts pledged for each Recipient, indexed by Recipient ID"
        }
      },
      "notice": "Get cumulative pledge amounts scoped to Noun ID, Trait Type, and Trait ID",
      "details": "Example: `pledgesForNounIdByTraitId(0, 1, 25)` accumulates all pledged pledge amounts for background (Trait Type 0) with Trait ID 1 for Noun ID 25. The value in `pledges[2]` is in the total amount that has been pledged to Recipient ID 2 Note: When accessing a Noun ID for an auctioned Noun, pledges for the open ID value `ANY_ID` will be added to total pledges"
    },
    "pledgesForNounOnAuction()": {
      "stateMutability": "view",
      "code": "function pledgesForNounOnAuction() external view returns (uint16 currentAuctionId, uint16 prevNonAuctionId, uint256[][5] currentAuctionPledges, uint256[][5] prevNonAuctionPledges)",
      "inputs": {},
      "outputs": {
        "currentAuctionId": {
          "type": "uint16",
          "description": "The ID of the Noun that is currently being auctioned"
        },
        "prevNonAuctionId": {
          "type": "uint16",
          "description": "If two Nouns were minted, this will be the ID of the non-auctioned Noun, otherwise uint16.max (65,535)"
        },
        "currentAuctionPledges": {
          "type": "uint256[][5]",
          "description": "Total pledges for the current auctioned Noun as a nested arrays indexed by Trait Type and Recipient ID"
        },
        "prevNonAuctionPledges": {
          "type": "uint256[][5]",
          "description": "If two Nouns were minted, this will contain the total pledges for the previous non-auctioned Noun as a nested arrays indexed by Trait Type and Recipient ID"
        }
      },
      "notice": "For the Noun that is currently on auction (and the previous non-auctioned Noun if it was minted at the same time), get cumulative pledge amounts pledged for each Recipient using requests that match the Noun's seed.",
      "details": "Example: The Noun on auction has an ID of 99 and a seed of [1,2,3,4,5] representing background, body, accessory, head, glasses Trait Types and respective Trait IDs. Calling `pledgesForNounOnAuction()` returns cumulative matching pledges for each trait that matches the seed such that: - `currentAuctionPledges[0]` returns the cumulative doantions amounts for all requests that are seeking background (Trait Type 0) with Trait ID 1 (i.e. the actual background value) for Noun ID 99. The value in `pledges[0][2]` is in the total amount that has been pledged to Recipient ID 2. If the Noun on auction was ID 101, there would additionally be return values for Noun 100, the non-auctioned Noun minted at the same time and `prevNonAuctionPledges` would be populated"
    },
    "pledgesForOnChainNoun(uint16)": {
      "stateMutability": "view",
      "code": "function pledgesForOnChainNoun(uint16 nounId) external view returns (uint256[][5] pledges)",
      "inputs": {
        "nounId": {
          "type": "uint16",
          "description": "Noun ID of an existing on-chain Noun"
        }
      },
      "outputs": {
        "pledges": {
          "type": "uint256[][5]",
          "description": "Cumulative amounts pledged for each Recipient that matches the on-chain Noun seed indexed by Trait Type and Recipient ID"
        }
      },
      "notice": "For an existing on-chain Noun, use its seed to find matching pledges",
      "details": "Example: `noun.seeds(1)` returns a seed of [1,2,3,4,5] representing background, body, accessory, head, glasses Trait Types and respective Trait IDs. Calling `pledgesForOnChainNoun(1)` returns cumulative matching pledges for each trait that matches the seed such that: - `pledges[0]` returns the cumulative doantions amounts for all requests that are seeking background (Trait Type 0) with Trait ID 1 for Noun ID 1. The value in `pledges[0][2]` is in the total amount that has been pledged to Recipient ID 2 Note: When accessing a Noun ID for an auctioned Noun, pledges for the open ID value `ANY_ID` will be added to total pledges"
    },
    "pledgesForUpcomingNoun()": {
      "stateMutability": "view",
      "code": "function pledgesForUpcomingNoun() external view returns (uint16 nextAuctionId, uint16 nextNonAuctionId, uint256[][][5] nextAuctionPledges, uint256[][][5] nextNonAuctionPledges)",
      "inputs": {},
      "outputs": {
        "nextAuctionId": {
          "type": "uint16",
          "description": "The ID of the next Noun that will be auctioned"
        },
        "nextNonAuctionId": {
          "type": "uint16",
          "description": "If two Nouns are due to be minted, this will be the ID of the non-auctioned Noun, otherwise uint16.max (65,535)"
        },
        "nextAuctionPledges": {
          "type": "uint256[][][5]",
          "description": "Total pledges for the next auctioned Noun as a nested arrays in the order Trait Type, Trait ID, and Recipient ID"
        },
        "nextNonAuctionPledges": {
          "type": "uint256[][][5]",
          "description": "If two Nouns are due to be minted, this will contain the total pledges for the next non-auctioned Noun as a nested arrays in the order Trait Type, Trait ID, and Recipient ID"
        }
      },
      "notice": "Use the next auctioned Noun Id (and non-auctioned Noun Id that may be minted in the same block) to get cumulative pledge amounts for each Recipient scoped by possible Trait Type and Trait ID.",
      "details": "See { pledgesForNounId } for detailed documentation of the nested array structure"
    },
    "recipients()": {
      "stateMutability": "view",
      "code": "function recipients() external view returns (struct NounSeek.Recipient[])",
      "inputs": {},
      "outputs": {
        "_0": {
          "type": "NounSeek.Recipient[]"
        }
      },
      "notice": "All recipients as Recipient structs"
    },
    "effectiveBPSAndReimbursementForPledgeTotal(uint256)": {
      "stateMutability": "view",
      "code": "function effectiveBPSAndReimbursementForPledgeTotal(uint256 total) external view returns (uint256 effectiveBPS, uint256 reimbursement)",
      "inputs": {
        "total": {
          "type": "uint256",
          "description": "A pledge amount"
        }
      },
      "outputs": {
        "effectiveBPS": {
          "type": "uint256",
          "description": "The basis point used to cacluate the reimbursement fee"
        },
        "reimbursement": {
          "type": "uint256",
          "description": "The reimbursement amount"
        }
      },
      "notice": "Given a pledge total, derive the reimbursement fee and basis points used to calculate it"
    },
    "glassesCount()": {
      "stateMutability": "view",
      "code": "function glassesCount() external view returns (uint16)",
      "inputs": {},
      "outputs": {
        "_0": {
          "type": "uint16",
          "description": "glassesCount"
        }
      },
      "notice": "the total number of glasses traits, fetched and cached via `updateTraitCounts()`"
    },
    "headCount()": {
      "stateMutability": "view",
      "code": "function headCount() external view returns (uint16)",
      "inputs": {},
      "outputs": {
        "_0": {
          "type": "uint16",
          "description": "headCount"
        }
      },
      "notice": "the total number of head traits, fetched and cached via `updateTraitCounts()`"
    },
    "maxReimbursement()": {
      "stateMutability": "view",
      "code": "function maxReimbursement() external view returns (uint256)",
      "inputs": {},
      "outputs": {
        "_0": {
          "type": "uint256",
          "description": "maxReimbursement"
        }
      },
      "notice": "maximum reimbursement for matching; with default BPS value, this is reached at 4 ETH total pledges",
      "details": "Owner can update"
    },
    "minReimbursement()": {
      "stateMutability": "view",
      "code": "function minReimbursement() external view returns (uint256)",
      "inputs": {},
      "outputs": {
        "_0": {
          "type": "uint256",
          "description": "minReimbursement"
        }
      },
      "notice": "minimum reimbursement for matching",
      "details": "The default attempts to cover 10 recipient matches each sent the default minimimum value (150_000 gas at 20 Gwei/gas) Owner can update"
    },
    "minValue()": {
      "stateMutability": "view",
      "code": "function minValue() external view returns (uint256)",
      "inputs": {},
      "outputs": {
        "_0": {
          "type": "uint256",
          "description": "minValue"
        }
      },
      "notice": "The minimum pledge value",
      "details": "Owner can update"
    },
    "nouns()": {
      "stateMutability": "view",
      "code": "function nouns() external view returns (contract INounsTokenLike)",
      "inputs": {},
      "outputs": {
        "_0": {
          "type": "contract INounsTokenLike",
          "description": "nouns contract address"
        }
      },
      "notice": "Retreives historical mapping of Noun ID -> seed"
    },
    "owner()": {
      "stateMutability": "view",
      "code": "function owner() external view returns (address)",
      "inputs": {},
      "outputs": {
        "_0": {
          "type": "address"
        }
      },
      "details": "Returns the address of the current owner."
    },
    "pause()": {
      "stateMutability": "nonpayable",
      "code": "function pause() external nonpayable",
      "inputs": {},
      "outputs": {},
      "notice": "Pauses the NounSeek contract. Pausing can be reversed by unpausing."
    },
    "paused()": {
      "stateMutability": "view",
      "code": "function paused() external view returns (bool)",
      "inputs": {},
      "outputs": {
        "_0": {
          "type": "bool"
        }
      },
      "details": "Returns true if the contract is paused, and false otherwise."
    },
    "pendingOwner()": {
      "stateMutability": "view",
      "code": "function pendingOwner() external view returns (address)",
      "inputs": {},
      "outputs": {
        "_0": {
          "type": "address"
        }
      },
      "details": "Returns the address of the pending owner."
    },
    "rawRequestById(address,uint256)": {
      "stateMutability": "view",
      "code": "function rawRequestById(address requester, uint256 requestId) external view returns (struct NounSeek.Request request)",
      "inputs": {
        "requester": {
          "type": "address"
        },
        "requestId": {
          "type": "uint256",
          "description": "The ID of the request"
        }
      },
      "outputs": {
        "request": {
          "type": "NounSeek.Request",
          "description": "The Request struct"
        }
      },
      "notice": "Get a specific raw Request (without status, includes deleted Requests)",
      "details": "Exists for low-level queries. The function { requestsByAddress } is better in most use-cases"
    },
    "rawRequestsByAddress(address)": {
      "stateMutability": "view",
      "code": "function rawRequestsByAddress(address requester) external view returns (struct NounSeek.Request[] requests)",
      "inputs": {
        "requester": {
          "type": "address",
          "description": "The address of the requester"
        }
      },
      "outputs": {
        "requests": {
          "type": "NounSeek.Request[]",
          "description": "An array of Request structs"
        }
      },
      "notice": "Get all raw Requests (without status, includes deleted Requests)",
      "details": "Exists for low-level queries. The function { requestsByAddress } is better in most use-cases"
    },
    "remove(uint256)": {
      "stateMutability": "nonpayable",
      "code": "function remove(uint256 requestId) external nonpayable returns (uint256 amount)",
      "inputs": {
        "requestId": {
          "type": "uint256",
          "description": "Request Id"
        }
      },
      "outputs": {
        "amount": {
          "type": "uint256"
        }
      },
      "notice": "Remove the specified request and return the associated amount.",
      "details": "Must be called by the Requester's address. If the Request has already been matched/sent to the Recipient or the current auction is ending soon, this will revert (See { _getRequestStatusAndParams } for calculations) If the Recipient of the Request is marked as inactive, the funds can be returned immediately"
    },
    "renounceOwnership()": {
      "stateMutability": "nonpayable",
      "code": "function renounceOwnership() external nonpayable",
      "inputs": {},
      "outputs": {},
      "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."
    },
    "requestMatchesNoun(tuple,uint16)": {
      "stateMutability": "view",
      "code": "function requestMatchesNoun(NounSeek.Request request, uint16 nounId) external view returns (bool)",
      "inputs": {
        "request": {
          "type": "NounSeek.Request"
        },
        "nounId": {
          "type": "uint16"
        }
      },
      "outputs": {
        "_0": {
          "type": "bool"
        }
      }
    },
    "requestsByAddress(address)": {
      "stateMutability": "view",
      "code": "function requestsByAddress(address requester) external view returns (struct NounSeek.RequestWithStatus[] requests)",
      "inputs": {
        "requester": {
          "type": "address",
          "description": "The address of the requester"
        }
      },
      "outputs": {
        "requests": {
          "type": "NounSeek.RequestWithStatus[]",
          "description": "An array of RequestWithStatus Structs"
        }
      },
      "notice": "Get requests, augemented with status, for non-removed Requests",
      "details": "Removes Requests marked as REMOVED, and includes Requests that have been previously matched. Do not rely on array index; use `request.id` to specify a Request when calling `remove()` See { _getRequestStatusAndParams } for calculations"
    },
    "setRecipientActive(uint256,bool)": {
      "stateMutability": "nonpayable",
      "code": "function setRecipientActive(uint256 recipientId, bool active) external nonpayable",
      "inputs": {
        "recipientId": {
          "type": "uint256",
          "description": "Recipient id based on its index within the recipients set"
        },
        "active": {
          "type": "bool",
          "description": "Active state"
        }
      },
      "outputs": {},
      "notice": "Toggles a Recipient's active state by its index within the set, reverts if Recipient is not configured",
      "details": "If the Done is not configured, a revert will be triggered"
    },
    "setMaxReimbursement(uint256)": {
      "stateMutability": "nonpayable",
      "code": "function setMaxReimbursement(uint256 newMaxReimbursement) external nonpayable",
      "inputs": {
        "newMaxReimbursement": {
          "type": "uint256",
          "description": "new maximum value"
        }
      },
      "outputs": {},
      "notice": "Sets the maximum reimbursement amount when matching"
    },
    "setMinReimbursement(uint256)": {
      "stateMutability": "nonpayable",
      "code": "function setMinReimbursement(uint256 newMinReimbursement) external nonpayable",
      "inputs": {
        "newMinReimbursement": {
          "type": "uint256",
          "description": "new minimum value"
        }
      },
      "outputs": {},
      "notice": "Sets the minium reimbursement amount when matching"
    },
    "setMinValue(uint256)": {
      "stateMutability": "nonpayable",
      "code": "function setMinValue(uint256 newMinValue) external nonpayable",
      "inputs": {
        "newMinValue": {
          "type": "uint256",
          "description": "new minimum value"
        }
      },
      "outputs": {},
      "notice": "Sets the minium value that can be pledged"
    },
    "setReimbursementBPS(uint16)": {
      "stateMutability": "nonpayable",
      "code": "function setReimbursementBPS(uint16 newReimbursementBPS) external nonpayable",
      "inputs": {
        "newReimbursementBPS": {
          "type": "uint16",
          "description": "new basis point value"
        }
      },
      "outputs": {},
      "notice": "Sets the standard reimbursement basis points"
    },
    "settle(uint8,uint16,uint16[])": {
      "stateMutability": "nonpayable",
      "code": "function settle(enum NounSeek.Traits trait, uint16 nounId, uint16[] recipientIds) external nonpayable returns (uint256 total, uint256 reimbursement)",
      "inputs": {
        "trait": {
          "type": "enum NounSeek.Traits",
          "description": "The Trait Type to fetch from an eligible Noun (see `Traits` Enum)"
        },
        "nounId": {
          "type": "uint16",
          "description": "The Noun to fetch the trait from. Must be the previous auctioned Noun ID or the previous non-auctioned Noun ID if it was minted at the same time."
        },
        "recipientIds": {
          "type": "uint16[]",
          "description": "An array of recipient IDs that have been pledged an amount if a Noun matches the specified trait."
        }
      },
      "outputs": {
        "total": {
          "type": "uint256",
          "description": "Total donated funds before reimbursement"
        },
        "reimbursement": {
          "type": "uint256",
          "description": "Reimbursement amount"
        }
      },
      "notice": "Sends pledged amounts to recipients by matching a requested trait to an eligible Noun. A portion of the pledged amount is sent to `msg.sender` to offset the gas costs of settling.",
      "details": "Only eligible Noun Ids are accepted. An eligible Noun Id is for the immediately preceeding auctioned Noun, or non-auctioned Noun if it was minted at the same time. Specifying a Noun Id for an auctioned Noun will matches against requests that have an open ID (ANY_ID) as well as specific ID. If immediately preceeding Noun to the previously auctioned Noun is non-auctioned, only specific ID requests will match. See function body for examples."
    },
    "traitHash(uint8,uint16,uint16)": {
      "stateMutability": "pure",
      "code": "function traitHash(enum NounSeek.Traits trait, uint16 traitId, uint16 nounId) external pure returns (bytes32 hash)",
      "inputs": {
        "trait": {
          "type": "enum NounSeek.Traits",
          "description": "The trait enum"
        },
        "traitId": {
          "type": "uint16",
          "description": "The ID of the trait"
        },
        "nounId": {
          "type": "uint16",
          "description": "The Noun ID"
        }
      },
      "outputs": {
        "hash": {
          "type": "bytes32",
          "description": "The hashed value"
        }
      },
      "notice": "The canonical key for requests that target the same `trait`, `traitId`, and `nounId`",
      "details": "Used to group requests by their parameters in the `amounts` mapping"
    },
    "transferOwnership(address)": {
      "stateMutability": "nonpayable",
      "code": "function transferOwnership(address newOwner) external nonpayable",
      "inputs": {
        "newOwner": {
          "type": "address"
        }
      },
      "outputs": {},
      "details": "Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one. Can only be called by the current owner."
    },
    "unpause()": {
      "stateMutability": "nonpayable",
      "code": "function unpause() external nonpayable",
      "inputs": {},
      "outputs": {},
      "notice": "Unpauses (resumes) the NounSeek contract. Unpausing can be reversed by pausing."
    },
    "updateTraitCounts()": {
      "stateMutability": "nonpayable",
      "code": "function updateTraitCounts() external nonpayable",
      "inputs": {},
      "outputs": {},
      "notice": "Update local Trait counts based on Noun Descriptor totals"
    },
    "weth()": {
      "stateMutability": "view",
      "code": "function weth() external view returns (contract IWETH)",
      "inputs": {},
      "outputs": {
        "_0": {
          "type": "contract IWETH",
          "description": "WETH contract address"
        }
      },
      "notice": "The address of the WETH contract"
    }
  },
  "events": {
    "Donated": {
      "code": "event Donated(uint256[] donations)",
      "inputs": {
        "pledges": {
          "type": "uint256[]",
          "indexed": false,
          "description": "The array of amounts indexed by Recipient ID sent to recipients"
        }
      },
      "notice": "Emitted when an eligible Noun matches one or more Requests"
    },
    "RecipientActiveStatusChanged": {
      "code": "event RecipientActiveStatusChanged(uint256 recipientId, bool active)",
      "inputs": {
        "recipientId": {
          "type": "uint256",
          "indexed": false
        },
        "active": {
          "type": "bool",
          "indexed": false
        }
      },
      "notice": "Emitted when a Recipient status has changed"
    },
    "RecipientAdded": {
      "code": "event RecipientAdded(uint256 recipientId, string name, address to, string description)",
      "inputs": {
        "recipientId": {
          "type": "uint256",
          "indexed": false
        },
        "name": {
          "type": "string",
          "indexed": false
        },
        "to": {
          "type": "address",
          "indexed": false
        },
        "description": {
          "type": "string",
          "indexed": false
        }
      },
      "notice": "Emitted when a Recipient is added"
    },
    "Matched": {
      "code": "event Matched(enum NounSeek.Traits indexed trait, uint16 traitId, uint16 indexed nounId, bytes32 indexed traitsHash)",
      "inputs": {
        "trait": {
          "type": "enum NounSeek.Traits",
          "indexed": true,
          "description": "Trait Type that matched"
        },
        "traitId": {
          "type": "uint16",
          "indexed": false,
          "description": "Trait ID that matched"
        },
        "nounId": {
          "type": "uint16",
          "indexed": true,
          "description": "Noun Id that matched"
        },
        "traitsHash": {
          "type": "bytes32",
          "indexed": true,
          "description": "Hash of trait, traitId, nounId"
        }
      },
      "notice": "Emitted when an eligible Noun matches one or more Requests",
      "details": "Used to update and/or invalidate Requests stored off-chain for these parameters"
    },
    "MaxReimbursementChanged": {
      "code": "event MaxReimbursementChanged(uint256 newMaxReimbursement)",
      "inputs": {
        "newMaxReimbursement": {
          "type": "uint256",
          "indexed": false
        }
      },
      "notice": "Emitted when the maxReimbursement changes"
    },
    "MinReimbursementChanged": {
      "code": "event MinReimbursementChanged(uint256 newMinReimbursement)",
      "inputs": {
        "newMinReimbursement": {
          "type": "uint256",
          "indexed": false
        }
      },
      "notice": "Emitted when the minReimbursement changes"
    },
    "MinValueChanged": {
      "code": "event MinValueChanged(uint256 newMinValue)",
      "inputs": {
        "newMinValue": {
          "type": "uint256",
          "indexed": false
        }
      },
      "notice": "Emitted when the minValue changes"
    },
    "OwnershipTransferStarted": {
      "code": "event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner)",
      "inputs": {
        "previousOwner": {
          "type": "address",
          "indexed": true
        },
        "newOwner": {
          "type": "address",
          "indexed": true
        }
      }
    },
    "OwnershipTransferred": {
      "code": "event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)",
      "inputs": {
        "previousOwner": {
          "type": "address",
          "indexed": true
        },
        "newOwner": {
          "type": "address",
          "indexed": true
        }
      }
    },
    "Paused": {
      "code": "event Paused(address account)",
      "inputs": {
        "account": {
          "type": "address",
          "indexed": false
        }
      }
    },
    "Reimbursed": {
      "code": "event Reimbursed(address indexed matcher, uint256 amount)",
      "inputs": {
        "matcher": {
          "type": "address",
          "indexed": true,
          "description": "The addressed that performed the matching function"
        },
        "amount": {
          "type": "uint256",
          "indexed": false,
          "description": "The reimbursement amount"
        }
      },
      "notice": "Emitted when an eligible Noun matches one or more Requests"
    },
    "ReimbursementBPSChanged": {
      "code": "event ReimbursementBPSChanged(uint256 newReimbursementBPS)",
      "inputs": {
        "newReimbursementBPS": {
          "type": "uint256",
          "indexed": false
        }
      },
      "notice": "Emitted when the baseReimbursementBPS changes"
    },
    "RequestAdded": {
      "code": "event RequestAdded(uint256 requestId, address indexed requester, enum NounSeek.Traits trait, uint16 traitId, uint16 recipientId, uint16 indexed nounId, bytes32 indexed traitsHash, uint256 amount, string message)",
      "inputs": {
        "requestId": {
          "type": "uint256",
          "indexed": false
        },
        "requester": {
          "type": "address",
          "indexed": true
        },
        "trait": {
          "type": "enum NounSeek.Traits",
          "indexed": false
        },
        "traitId": {
          "type": "uint16",
          "indexed": false
        },
        "recipientId": {
          "type": "uint16",
          "indexed": false
        },
        "nounId": {
          "type": "uint16",
          "indexed": true
        },
        "traitsHash": {
          "type": "bytes32",
          "indexed": true
        },
        "amount": {
          "type": "uint256",
          "indexed": false
        },
        "message": {
          "type": "string",
          "indexed": false
        }
      },
      "notice": "Emitted when a Request is added"
    },
    "RequestRemoved": {
      "code": "event RequestRemoved(uint256 requestId, address indexed requester, enum NounSeek.Traits trait, uint16 traitId, uint16 indexed nounId, uint16 recipientId, bytes32 indexed traitsHash, uint256 amount)",
      "inputs": {
        "requestId": {
          "type": "uint256",
          "indexed": false
        },
        "requester": {
          "type": "address",
          "indexed": true
        },
        "trait": {
          "type": "enum NounSeek.Traits",
          "indexed": false
        },
        "traitId": {
          "type": "uint16",
          "indexed": false
        },
        "nounId": {
          "type": "uint16",
          "indexed": true
        },
        "recipientId": {
          "type": "uint16",
          "indexed": false
        },
        "traitsHash": {
          "type": "bytes32",
          "indexed": true
        },
        "amount": {
          "type": "uint256",
          "indexed": false
        }
      },
      "notice": "Emitted when a Request is removed"
    },
    "Unpaused": {
      "code": "event Unpaused(address account)",
      "inputs": {
        "account": {
          "type": "address",
          "indexed": false
        }
      }
    }
  },
  "errors": {
    "AlreadyRemoved": {
      "code": "error AlreadyRemoved()",
      "inputs": {},
      "notice": "Thrown when attempting to remove a Request that was previously removed."
    },
    "AuctionEndingSoon": {
      "code": "error AuctionEndingSoon()",
      "inputs": {},
      "notice": "Thrown when an attempting to remove a Request within `AUCTION_END_LIMIT` (5 minutes) of auction end."
    },
    "PledgeSent": {
      "code": "error PledgeSent()",
      "inputs": {},
      "notice": "Thrown when an attempting to remove a Request that was previously matched"
    },
    "InactiveRecipient": {
      "code": "error InactiveRecipient()",
      "inputs": {},
      "notice": "Thrown when an attempting to add a Request that pledges an amount to an inactive Recipient"
    },
    "IneligibleNounId": {
      "code": "error IneligibleNounId()",
      "inputs": {},
      "notice": "Thrown when attempting to match an eligible Noun. Can only match a Noun previous to the current on auction"
    },
    "MatchFound": {
      "code": "error MatchFound(uint16 nounId)",
      "inputs": {
        "nounId": {
          "type": "uint16"
        }
      },
      "notice": "Thrown when an attempting to remove a Request that matches the current or previous Noun"
    },
    "NoMatch": {
      "code": "error NoMatch()",
      "inputs": {},
      "notice": "Thrown when attempting to match the eligible Noun that has no matching Requests for the specified Trait Type and Trait ID"
    },
    "ValueTooLow": {
      "code": "error ValueTooLow()",
      "inputs": {},
      "notice": "Thrown when an attempting to add a Request with value below `minValue`"
    }
  },
  "path": "",
  "name": "NounSeek"
}
